
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>谈谈 Objective-C block 的实现 - 我的愚与渔</title>
  <meta name="author" content="Sring Zhao">

  
  <meta name="description" content="我是前言 这篇文章是我自己最近在学习 block 后的一个简单总结。
这篇总结你可以读到： block 的本质是什么
block 如何捕获变量
block 生命周期管理 block 的本质 在开始了解 block 的实现前，我们先简单的回顾一下 block 是什么。
block 是闭包的一种， &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://strzhao.github.io/blog/2018/03/11/block-liao-jie-xia">
  <link href="/favicon.ico" rel="icon">
  
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="/javascripts/ender.js"></script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <link href="/atom.xml" rel="alternate" title="我的愚与渔" type="application/atom+xml">
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  

</head>

<body   class="no-sidebar"  >
  <header role="banner"><hgroup>
  <h1>我的愚与渔</h1>
  
    <h2><a href="/">StrZ</a></h2>
  
</hgroup>

</header>
  <nav role="navigation">
  
<form action="https://www.google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:strzhao.github.io" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div>
<article class="hentry" role="article">
  
  <header>
    
      <h1 class="entry-title">谈谈 Objective-C Block 的实现</h1>
    
    
      <p class="meta">
        








  


<time datetime="2018-03-11T12:13:52+08:00" pubdate data-updated="true"></time>
        
      </p>
    
  </header>


<div class="entry-content"><h2>我是前言</h2>

<p>这篇文章是我自己最近在学习 block 后的一个简单总结。<br/>
这篇总结你可以读到：</p>

<ul>
<li>block 的本质是什么</li>
<li>block 如何捕获变量</li>
<li>block 生命周期管理</li>
</ul>


<h2>block 的本质</h2>

<p>在开始了解 block 的实现前，我们先简单的回顾一下 block 是什么。<br/>
block 是<a href="https://zh.wikipedia.org/wiki/%E9%97%AD%E5%8C%85_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6">闭包</a>的一种，是闭包在 C 语言上的实现。<br/>
那么闭包是什么呢？用一句话概括：</p>

<blockquote><p>带有自动变量的匿名函数</p></blockquote>

<p>所以现在问题的核心就是如何在 C 上实现带有自动变量的匿名函数。</p>

<p>闭包的典型实现方式是定义一个特殊的数据结构，保存了函数地址指针与闭包创建时的函数的词法环境。
C 语言的 block 实现也确实是这样的思路，而其中定义数据结构，保存函数指针和函数词法环境这样的脏活d都交给编译器去完成了。</p>

<p><em>数据结构</em>，<em>函数指针</em>，<em>函数词法环境</em>，牢记这几个核心点，我们一起来看看编译器都是怎么完成这些工作的。</p>

<p>我们新建一个 main.c, 其中代码如下:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
</span><span class='line'>
</span><span class='line'>    <span class="kt">void</span> <span class="p">(</span><span class="o">^</span><span class="n">blk</span><span class="p">)(</span><span class="kt">void</span><span class="p">)</span> <span class="o">=</span> <span class="o">^</span><span class="p">{</span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Hello, World!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);};</span>
</span><span class='line'>    <span class="n">blk</span><span class="p">();</span>
</span><span class='line'>    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>然后我们执行下边命令，clang 可以把带有 block 的源代码转换成 C++ 的代码。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="n">clang</span> <span class="o">-</span><span class="n">rewrite</span><span class="o">-</span><span class="n">objc</span> <span class="n">main</span><span class="p">.</span><span class="n">c</span>
</span></code></pre></td></tr></table></div></figure>


<p>转换后的代码核心部分如下：(同时把类型转换也去掉)</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="k">struct</span> <span class="n">__block_impl</span> <span class="p">{</span>
</span><span class='line'>  <span class="kt">void</span> <span class="o">*</span><span class="n">isa</span><span class="p">;</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">Flags</span><span class="p">;</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">Reserved</span><span class="p">;</span>
</span><span class='line'>  <span class="kt">void</span> <span class="o">*</span><span class="n">FuncPtr</span><span class="p">;</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'><span class="k">struct</span> <span class="n">__main_block_impl_0</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">struct</span> <span class="n">__block_impl</span> <span class="n">impl</span><span class="p">;</span>
</span><span class='line'>  <span class="k">struct</span> <span class="n">__main_block_desc_0</span><span class="o">*</span> <span class="n">Desc</span><span class="p">;</span>
</span><span class='line'>  <span class="n">__main_block_impl_0</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">fp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">__main_block_desc_0</span> <span class="o">*</span><span class="n">desc</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">impl</span><span class="p">.</span><span class="n">isa</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">_NSConcreteStackblock</span><span class="p">;</span>
</span><span class='line'>    <span class="n">impl</span><span class="p">.</span><span class="n">Flags</span> <span class="o">=</span> <span class="n">flags</span><span class="p">;</span>
</span><span class='line'>    <span class="n">impl</span><span class="p">.</span><span class="n">FuncPtr</span> <span class="o">=</span> <span class="n">fp</span><span class="p">;</span>
</span><span class='line'>    <span class="n">Desc</span> <span class="o">=</span> <span class="n">desc</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'><span class="k">static</span> <span class="kt">void</span> <span class="nf">__main_block_func_0</span><span class="p">(</span><span class="k">struct</span> <span class="n">__main_block_impl_0</span> <span class="o">*</span><span class="n">__cself</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Hello, World!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">static</span> <span class="k">struct</span> <span class="n">__main_block_desc_0</span> <span class="p">{</span>
</span><span class='line'>  <span class="kt">size_t</span> <span class="n">reserved</span><span class="p">;</span>
</span><span class='line'>  <span class="kt">size_t</span> <span class="n">block_size</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span> <span class="n">__main_block_desc_0_DATA</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">__main_block_impl_0</span><span class="p">)};</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
</span><span class='line'>
</span><span class='line'>    <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">blk</span><span class="p">)(</span><span class="kt">void</span><span class="p">)</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">__main_block_impl_0</span><span class="p">(</span><span class="n">__main_block_func_0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">__main_block_desc_0_DATA</span><span class="p">);</span>
</span><span class='line'>    <span class="n">blk</span><span class="o">-&gt;</span><span class="n">impl</span><span class="p">.</span><span class="n">FuncPtr</span><span class="p">(</span><span class="n">blk</span><span class="p">);</span>
</span><span class='line'>    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>可以看到 block 通过在编译后就是普通的 C++ 代码了，围绕之前的核心要点我们逐个来分析下，首先是数据结构部分 <code>__main_block_impl_0</code>，我们把结构体拍扁，然后去掉构造函数。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="k">struct</span> <span class="n">__main_block_impl_0</span> <span class="p">{</span>
</span><span class='line'>    <span class="kt">void</span> <span class="o">*</span><span class="n">isa</span><span class="p">;</span>  <span class="c1">// 用于实现 block 对象的功能</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">Flags</span><span class="p">;</span>  <span class="c1">// 后边说明</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">Reserved</span><span class="p">;</span> <span class="c1">// 保留字段</span>
</span><span class='line'>    <span class="kt">void</span> <span class="o">*</span><span class="n">FuncPtr</span><span class="p">;</span> <span class="c1">// 函数指针 在构造时会对应到定义好的匿名函数</span>
</span><span class='line'>    <span class="k">struct</span> <span class="n">__main_block_desc_0</span><span class="o">*</span> <span class="n">Desc</span><span class="p">;</span> <span class="c1">// 后边说明用途</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">struct</span> <span class="n">__main_block_desc_0</span> <span class="p">{</span>
</span><span class='line'>  <span class="kt">size_t</span> <span class="n">reserved</span><span class="p">;</span>  <span class="c1">// 保留字段</span>
</span><span class='line'>  <span class="kt">size_t</span> <span class="n">block_size</span><span class="p">;</span> <span class="c1">// block 的大小 用于 malloc </span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<ol>
<li>果然 block 被转换成了相应的一个数据结构</li>
<li>该结构体有一个 isa 指针，所以 block 是一个 OC 对象。</li>
<li>Flags 标记位，这个用于生命周期管理，后边会详细说明。</li>
<li>Reserved 保留字段。</li>
<li>函数指针，显然就是用于保存 block 对应的"匿名函数"的</li>
<li><code>__main_block_desc_0</code> 结构体指针，也后边再来详细说明。</li>
</ol>


<p>明白了结构体，我们继续来看函数指针 <code>__block_impl</code> 指向的函数</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="k">static</span> <span class="kt">void</span> <span class="nf">__main_block_func_0</span><span class="p">(</span><span class="k">struct</span> <span class="n">__main_block_impl_0</span> <span class="o">*</span><span class="n">__cself</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Hello, World!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>对应的就是之前 block 的表达式部分。<br/>
编译器把一个表达式根据它所属的类以及在类中出现的顺序在编译成一个普通的 C 函数, 而 block 对象持有了这个函数的函数指针，此时 block 就已经可以调用了。<br/>
而其中的参数 <code>struct __main_block_impl_0 *__cself</code> 非常有意思，因为他很好的体现了编译器是如何处理 Objective-C 的 OC 方法的，我们来看一个普通的 OC 方法：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="o">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nl">method</span><span class="p">:(</span><span class="kt">int</span><span class="p">)</span><span class="n">arg</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">NSLog</span><span class="p">(</span><span class="err">@</span><span class="s">&quot;%@ %d&quot;</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">arg</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>在编译成 C++ 后大概为这样：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="kt">void</span> <span class="nf">_I_Object_method</span><span class="p">(</span><span class="k">struct</span> <span class="n">Object</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="n">SEL</span> <span class="n">_cmd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">arg</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">NSLog</span><span class="p">(</span><span class="err">@</span><span class="s">&quot;%@ %d&quot;</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">arg</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这里的处理和 block 中对方法的处理是一模一样的。<br/>
这也说明了为什么我们在 OC 方法中可以使用 self 指针的原因。<br/>
额外说一点编译器怎么处理 OC 往一个对象发送消息。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="p">[</span><span class="n">obj</span> <span class="nl">method</span><span class="p">:</span><span class="mi">1</span><span class="p">]</span> <span class="c1">// 会被编译成下边的形式</span>
</span><span class='line'><span class="n">objc_msgSend</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">sel_resigtName</span><span class="p">(</span><span class="s">&quot;method:&quot;</span><span class="p">),</span> <span class="mi">1</span><span class="p">);</span> <span class="c1">// 这里的 obj 就是传到函数中的 self 指针。</span>
</span></code></pre></td></tr></table></div></figure>


<p>因为例子中没有使用外部的变量，所有我们暂时先略过自动变量的实现问题，最后我们来看看 block 的使用。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">blk</span><span class="p">)(</span><span class="kt">void</span><span class="p">)</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">__main_block_impl_0</span><span class="p">(</span><span class="n">__main_block_func_0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">__main_block_desc_0_DATA</span><span class="p">);</span> <span class="err">\\</span> <span class="kt">void</span> <span class="p">(</span><span class="o">^</span><span class="n">blk</span><span class="p">)(</span><span class="kt">void</span><span class="p">)</span> <span class="o">=</span> <span class="o">^</span><span class="p">{</span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Hello, World!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);};</span>
</span><span class='line'><span class="n">blk</span><span class="o">-&gt;</span><span class="n">impl</span><span class="p">.</span><span class="n">FuncPtr</span><span class="p">(</span><span class="n">blk</span><span class="p">);</span> <span class="err">\\</span> <span class="n">blk</span><span class="p">();</span>
</span></code></pre></td></tr></table></div></figure>


<p>这里的 block 就是在<em>栈</em>上构造的 <code>__main_block_impl_0</code> 结构体，其中参数为 <code>__main_block_func_0</code> 函数指针和 <code>__main_block_desc_0_DATA</code> 静态的结构体指针。</p>

<p>至此基本明白了 block 的实现，我们总结一下：block 会被编译成一个 C 结构体对象和一个 C 函数，且 C 结构体拥有这个 C 函数指针。<br/>
定义一个 block 就是初始化一个该 C 结构体的结构体指针，block 的调用就是调用该结构体指针指向的 C 函数, 并且把自己作为参数传递进去。<br/>
但是我们也多了很多疑问，我们先做一个记录，后边再来一一解释：</p>

<ul>
<li>block 对象是在栈上的，那么如何超出作用域而存在 ？</li>
<li>Flags 的作用是什么 ?</li>
</ul>


<h3>block 如何捕获变量</h3>

<p>我们先继续之前的 block 实现，把自动变量的实现先弄明白。<br/>
C 函数中可能用到的变量有很多，其中全局静态变量和全局变量显然直接使用就好了，不需要特别处理。
我们重点来看看无法直接使用的，先从栈上的基本类型变量开始，继续使用 clang 编译下边的代码。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
</span><span class='line'>
</span><span class='line'>    <span class="kt">int</span> <span class="n">val</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
</span><span class='line'>    <span class="kt">void</span> <span class="p">(</span><span class="o">^</span><span class="n">blk</span><span class="p">)(</span><span class="kt">void</span><span class="p">)</span> <span class="o">=</span> <span class="o">^</span><span class="p">{</span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Hello, World! val = %d&quot;</span><span class="p">,</span> <span class="n">val</span><span class="p">);};</span>
</span><span class='line'>    <span class="n">blk</span><span class="p">();</span>
</span><span class='line'>    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>删掉无关代码我们得到以下代码</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="k">struct</span> <span class="n">__main_block_impl_0</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">struct</span> <span class="n">__block_impl</span> <span class="n">impl</span><span class="p">;</span>
</span><span class='line'>  <span class="k">struct</span> <span class="n">__main_block_desc_0</span><span class="o">*</span> <span class="n">Desc</span><span class="p">;</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">val</span><span class="p">;</span>
</span><span class='line'>  <span class="n">__main_block_impl_0</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">fp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">__main_block_desc_0</span> <span class="o">*</span><span class="n">desc</span><span class="p">,</span> <span class="kt">int</span> <span class="n">_val</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">:</span> <span class="n">val</span><span class="p">(</span><span class="n">_val</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">impl</span><span class="p">.</span><span class="n">isa</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">_NSConcreteStackblock</span><span class="p">;</span>
</span><span class='line'>    <span class="n">impl</span><span class="p">.</span><span class="n">Flags</span> <span class="o">=</span> <span class="n">flags</span><span class="p">;</span>
</span><span class='line'>    <span class="n">impl</span><span class="p">.</span><span class="n">FuncPtr</span> <span class="o">=</span> <span class="n">fp</span><span class="p">;</span>
</span><span class='line'>    <span class="n">Desc</span> <span class="o">=</span> <span class="n">desc</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="k">static</span> <span class="kt">void</span> <span class="nf">__main_block_func_0</span><span class="p">(</span><span class="k">struct</span> <span class="n">__main_block_impl_0</span> <span class="o">*</span><span class="n">__cself</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">val</span> <span class="o">=</span> <span class="n">__cself</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">;</span> <span class="c1">// bound by copy</span>
</span><span class='line'>    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Hello, World! val = %d&quot;</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
</span><span class='line'>
</span><span class='line'>    <span class="kt">int</span> <span class="n">val</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
</span><span class='line'>    <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">blk</span><span class="p">)(</span><span class="kt">void</span><span class="p">)</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">__main_block_impl_0</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">__main_block_func_0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">__main_block_desc_0_DATA</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
</span><span class='line'>    <span class="n">blk</span><span class="o">-&gt;</span><span class="n">impl</span><span class="p">.</span><span class="n">FuncPtr</span><span class="p">(</span><span class="n">blk</span><span class="p">);</span>
</span><span class='line'>    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<ol>
<li>从这里我们不难发现，参数 val 其实是作为 block 对应的结构体的一个成员变量在初始化时作为参数传递进去的，而使用的时候也只需要通过访问该结构体指针 <code>__main_block_impl_0</code> 的成员变量即可。</li>
<li>block 中操作的 val 和外边的 val 已经没有关系了，所以修改 block 中的 val 是没有办法修改外部的 val 的（编译器通过抛出错误告诉我们这样是行不通的）。</li>
</ol>


<p>那么想要在 block 中修改 val 要怎么做呢？就要用到我们经常使用的 __block 修饰符。（局部静态变量也可以但是几乎不用）</p>

<h4>__block 修饰符</h4>

<p>我们可以先试着猜测一下 <code>__block</code> 修饰符会做什么，先前 block 通过构造结构体捕获了匿名函数和变量，达到可以随意使用匿名函数和变量的目的，现在会怎么做？<br/>
想好了，那我们继续来看 <code>__block</code> 修饰符都做了什么。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">__block</span> <span class="kt">int</span> <span class="n">val</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
</span><span class='line'>    <span class="kt">void</span> <span class="p">(</span><span class="o">^</span><span class="n">blk</span><span class="p">)(</span><span class="kt">void</span><span class="p">)</span> <span class="o">=</span> <span class="o">^</span><span class="p">{</span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Hello, World! val = %d&quot;</span><span class="p">,</span> <span class="n">val</span><span class="p">);};</span>
</span><span class='line'>    <span class="n">blk</span><span class="p">();</span>
</span><span class='line'>    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>得到以下代码</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="k">struct</span> <span class="n">__block_byref_val_0</span> <span class="p">{</span>
</span><span class='line'>  <span class="kt">void</span> <span class="o">*</span><span class="n">__isa</span><span class="p">;</span>
</span><span class='line'>  <span class="n">__block_byref_val_0</span> <span class="o">*</span><span class="n">__forwarding</span><span class="p">;</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">__flags</span><span class="p">;</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">__size</span><span class="p">;</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">val</span><span class="p">;</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="k">struct</span> <span class="n">__main_block_impl_0</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">struct</span> <span class="n">__block_impl</span> <span class="n">impl</span><span class="p">;</span>
</span><span class='line'>  <span class="k">struct</span> <span class="n">__main_block_desc_0</span><span class="o">*</span> <span class="n">Desc</span><span class="p">;</span>
</span><span class='line'>  <span class="n">__block_byref_val_0</span> <span class="o">*</span><span class="n">val</span><span class="p">;</span> <span class="c1">// by ref</span>
</span><span class='line'>  <span class="n">__main_block_impl_0</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">fp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">__main_block_desc_0</span> <span class="o">*</span><span class="n">desc</span><span class="p">,</span> <span class="n">__block_byref_val_0</span> <span class="o">*</span><span class="n">_val</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">:</span> <span class="n">val</span><span class="p">(</span><span class="n">_val</span><span class="o">-&gt;</span><span class="n">__forwarding</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">impl</span><span class="p">.</span><span class="n">isa</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">_NSConcreteStackblock</span><span class="p">;</span>
</span><span class='line'>    <span class="n">impl</span><span class="p">.</span><span class="n">Flags</span> <span class="o">=</span> <span class="n">flags</span><span class="p">;</span>
</span><span class='line'>    <span class="n">impl</span><span class="p">.</span><span class="n">FuncPtr</span> <span class="o">=</span> <span class="n">fp</span><span class="p">;</span>
</span><span class='line'>    <span class="n">Desc</span> <span class="o">=</span> <span class="n">desc</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="k">static</span> <span class="kt">void</span> <span class="nf">__main_block_func_0</span><span class="p">(</span><span class="k">struct</span> <span class="n">__main_block_impl_0</span> <span class="o">*</span><span class="n">__cself</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">__block_byref_val_0</span> <span class="o">*</span><span class="n">val</span> <span class="o">=</span> <span class="n">__cself</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">;</span> <span class="c1">// bound by ref</span>
</span><span class='line'>  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Hello, World! val = %d&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">val</span><span class="o">-&gt;</span><span class="n">__forwarding</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">));</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="k">static</span> <span class="kt">void</span> <span class="nf">__main_block_copy_0</span><span class="p">(</span><span class="k">struct</span> <span class="n">__main_block_impl_0</span><span class="o">*</span><span class="n">dst</span><span class="p">,</span> <span class="k">struct</span> <span class="n">__main_block_impl_0</span><span class="o">*</span><span class="n">src</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">_block_object_assign</span><span class="p">((</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">dst</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">src</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">static</span> <span class="kt">void</span> <span class="nf">__main_block_dispose_0</span><span class="p">(</span><span class="k">struct</span> <span class="n">__main_block_impl_0</span><span class="o">*</span><span class="n">src</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">_block_object_dispose</span><span class="p">((</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">src</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">static</span> <span class="k">struct</span> <span class="n">__main_block_desc_0</span> <span class="p">{</span>
</span><span class='line'>  <span class="kt">size_t</span> <span class="n">reserved</span><span class="p">;</span>
</span><span class='line'>  <span class="kt">size_t</span> <span class="n">block_size</span><span class="p">;</span>
</span><span class='line'>  <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">copy</span><span class="p">)(</span><span class="k">struct</span> <span class="n">__main_block_impl_0</span><span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">__main_block_impl_0</span><span class="o">*</span><span class="p">);</span>
</span><span class='line'>  <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">dispose</span><span class="p">)(</span><span class="k">struct</span> <span class="n">__main_block_impl_0</span><span class="o">*</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span> <span class="n">__main_block_desc_0_DATA</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">__main_block_impl_0</span><span class="p">),</span> <span class="n">__main_block_copy_0</span><span class="p">,</span> <span class="n">__main_block_dispose_0</span><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">__block_byref_val_0</span> <span class="n">val</span> <span class="o">=</span> <span class="p">{(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="mi">0</span><span class="p">,(</span><span class="n">__block_byref_val_0</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">val</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">__block_byref_val_0</span><span class="p">),</span> <span class="mi">3</span><span class="p">};</span>
</span><span class='line'>    <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">blk</span><span class="p">)(</span><span class="kt">void</span><span class="p">)</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">__main_block_impl_0</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">__main_block_func_0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">__main_block_desc_0_DATA</span><span class="p">,</span> <span class="p">(</span><span class="n">__block_byref_val_0</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">val</span><span class="p">,</span> <span class="mi">570425344</span><span class="p">);</span>
</span><span class='line'>    <span class="n">blk</span><span class="o">-&gt;</span><span class="n">impl</span><span class="p">.</span><span class="n">FuncPtr</span><span class="p">(</span><span class="n">blk</span><span class="p">);</span>
</span><span class='line'>    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<ol>
<li>我们可以看到变量 val 已经变成了对象 <code>__block_byref_val_0</code>, 之前的 block 对象 <code>__main_block_impl_0</code> 也拥有了 <code>__block_byref_val_0</code> 结构体实例指针，修改 val 就变成了修改结构体指针指向的结构体实例的变量 val 的值。</li>
<li>可能比之前我们想象的要复杂一些，但从本质来说就是<em>通过直接传值修改为传指针</em>，这和我们之前的猜测应该是差不多的。</li>
</ol>


<p>至此我们已经基本明白了 block 的实现。<br/>
但是似乎事情也变得复杂了很多，我们还有这些疑问没有解决，而这些问题都和 block 的生命周期有关：</p>

<ul>
<li>block 对象是在栈上的，那么如何超出作用域而存在 ？</li>
<li>Flags 的作用是什么 ?</li>
<li><code>__main_block_desc_0</code> 中 <code>copy</code> 和 <code>dispose</code> 函数的意义是什么？</li>
<li><code>__block_byref_val_0</code> 中 <code>__forwarding</code> 指针的意义是什么？</li>
</ul>


<h3>block 的生命周期管理</h3>

<h4>block 的生命周期管理</h4>

<p>稀缺是一个基本事实，在计算机中也是，正如堆栈的设计是为了提高内存的使用效率, 不同类型的 block 也是基于这样的目的设计的，也我们来看看 block 的几个类型：</p>

<p><img src="http://oaeal18u2.bkt.clouddn.com/2018-03-13%2012.26.48.png" alt="2018-03-13 12.26.48.png" /></p>

<p>那么现在可以回答来在栈上构造的 block 对象是如何超出作用域而存在的问题了<br/>
我们通过看 block 作为函数返回的代码来理解这个过程:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="kt">float</span> <span class="o">^</span><span class="p">(</span><span class="kt">float</span> <span class="n">x</span><span class="p">)</span> <span class="n">doubel</span><span class="p">(</span><span class="kt">float</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="o">^</span><span class="p">(</span><span class="kt">float</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">x</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>
</span><span class='line'>    <span class="p">};</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 编译后</span>
</span><span class='line'>
</span><span class='line'><span class="kt">float</span> <span class="o">^</span><span class="p">(</span><span class="kt">float</span> <span class="n">x</span><span class="p">)</span> <span class="n">doubel</span><span class="p">(</span><span class="kt">float</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">blk</span> <span class="n">tmp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">__func_block_impl_0</span><span class="p">(</span><span class="n">__func_block_func_0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">__func_block_desc_0_DATA</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">tmp</span> <span class="o">=</span> <span class="n">objc_retainBlock</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span> <span class="c1">// 从栈上复制到堆上</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">return</span> <span class="nf">objc_autoreleaseReturnValue</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span> <span class="c1">// 加到 autoreleasepool 中</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<ol>
<li>栈上的 block 通过 objc_retainBlock 可以复制到堆上。</li>
<li>加到 autoreleasepool 就可以在函数外被使用了</li>
</ol>


<p>我们深入的来了解下 <code>objc_retainBlock</code> 如何把 block 复制到堆上的，通过 objc4 运行时库 我们可以看到 <code>objc_retainBlock</code> 实际上就是 <code>_Block_copy</code> 函数
我们直接来看看 <code>_Block_copy</code> 的<a href="http://llvm.org/svn/llvm-project/compiler-rt/trunk/lib/BlocksRuntime/runtime.c">源码</a>实现 (代码暂时把 GC 部分都先去掉了)</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="kt">void</span> <span class="o">*</span><span class="nf">_Block_copy</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="c1">// 1</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">_Block_copy_internal</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">WANTS_ONE</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">_Block_copy_internal</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">struct</span> <span class="n">Block_layout</span> <span class="o">*</span><span class="n">aBlock</span><span class="p">;</span>
</span><span class='line'>    <span class="k">const</span> <span class="kt">bool</span> <span class="n">wantsOne</span> <span class="o">=</span> <span class="p">(</span><span class="n">WANTS_ONE</span> <span class="o">&amp;</span> <span class="n">flags</span><span class="p">)</span> <span class="o">==</span> <span class="n">WANTS_ONE</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">arg</span><span class="p">)</span> <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// 2</span>
</span><span class='line'>    <span class="n">aBlock</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">Block_layout</span> <span class="o">*</span><span class="p">)</span><span class="n">arg</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// 3</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">aBlock</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">BLOCK_NEEDS_FREE</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="c1">// latches on high</span>
</span><span class='line'>        <span class="n">latching_incr_int</span><span class="p">(</span><span class="o">&amp;</span><span class="n">aBlock</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">aBlock</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// 4</span>
</span><span class='line'>    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">aBlock</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">BLOCK_IS_GLOBAL</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">aBlock</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// 5</span>
</span><span class='line'>    <span class="k">struct</span> <span class="n">Block_layout</span> <span class="o">*</span><span class="n">result</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">aBlock</span><span class="o">-&gt;</span><span class="n">descriptor</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">);</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">result</span><span class="p">)</span> <span class="k">return</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="mi">0</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// 6</span>
</span><span class='line'>    <span class="n">memmove</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">aBlock</span><span class="p">,</span> <span class="n">aBlock</span><span class="o">-&gt;</span><span class="n">descriptor</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">);</span> <span class="c1">// bitcopy first</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// 7</span>
</span><span class='line'>    <span class="n">result</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">BLOCK_REFCOUNT_MASK</span><span class="p">);</span>    <span class="c1">// XXX not needed</span>
</span><span class='line'>    <span class="n">result</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">BLOCK_NEEDS_FREE</span> <span class="o">|</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// 8</span>
</span><span class='line'>    <span class="n">result</span><span class="o">-&gt;</span><span class="n">isa</span> <span class="o">=</span> <span class="n">_NSConcreteMallocBlock</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// 9</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">result</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">BLOCK_HAS_COPY_DISPOSE</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="p">(</span><span class="o">*</span><span class="n">aBlock</span><span class="o">-&gt;</span><span class="n">descriptor</span><span class="o">-&gt;</span><span class="n">copy</span><span class="p">)(</span><span class="n">result</span><span class="p">,</span> <span class="n">aBlock</span><span class="p">);</span> <span class="c1">// do fixup</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<ol>
<li><code>_Block_copy</code> 内部调用的是 <code>_Block_copy_internal</code></li>
<li>获取 block 的结构体对象指针</li>
<li>BLOCK_NEEDS_FREE 说明已经是一个堆上的 block 了，那么简单的增加引用计数即可, 这里也很好的说明了 flag 是做什么用的。</li>
<li>BLOCK_IS_GLOBAL 说明是一个全局的 block，直接返回即可。</li>
<li>在堆上创建内存，可以看到之前 <code>__main_block_desc_0</code> 的 <code>block_size</code> 此时就派上用场了。</li>
<li>复制数据结构</li>
<li>flags 设置上 BLOCK_NEEDS_FREE 用来说明已经是堆上的</li>
<li>设置 isa 为 _NSConcreteMallocBlock 类型。</li>
<li>如果设置了 BLOCK_HAS_COPY_DISPOSE 就去执行 descriptor 的 copy 函数，这个留到下边再说明。</li>
</ol>


<p>复制到堆上就需要自己来管理 block 的内存释放了，而这个过程是通过 <code>Block_release()</code> 来完成的，我们继续要看代码。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="kt">void</span> <span class="nf">_Block_release</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">struct</span> <span class="n">Block_layout</span> <span class="o">*</span><span class="n">aBlock</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">Block_layout</span> <span class="o">*</span><span class="p">)</span><span class="n">arg</span><span class="p">;</span>
</span><span class='line'>    <span class="kt">int32_t</span> <span class="n">newCount</span><span class="p">;</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">aBlock</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// 1</span>
</span><span class='line'>    <span class="n">newCount</span> <span class="o">=</span> <span class="n">latching_decr_int</span><span class="p">(</span><span class="o">&amp;</span><span class="n">aBlock</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">BLOCK_REFCOUNT_MASK</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// 2</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">newCount</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// 3</span>
</span><span class='line'>   <span class="k">if</span> <span class="p">(</span><span class="n">aBlock</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">BLOCK_NEEDS_FREE</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="n">aBlock</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">BLOCK_HAS_COPY_DISPOSE</span><span class="p">)(</span><span class="o">*</span><span class="n">aBlock</span><span class="o">-&gt;</span><span class="n">descriptor</span><span class="o">-&gt;</span><span class="n">dispose</span><span class="p">)(</span><span class="n">aBlock</span><span class="p">);</span>
</span><span class='line'>        <span class="c1">// 4</span>
</span><span class='line'>        <span class="n">_Block_deallocator</span><span class="p">(</span><span class="n">aBlock</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="c1">// 5</span>
</span><span class='line'>    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">aBlock</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">BLOCK_IS_GLOBAL</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Block_release called upon a stack Block: %p, ignored</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">aBlock</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">static</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">_Block_deallocator</span><span class="p">)(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="p">))</span><span class="n">free</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<ol>
<li>每次 release 都会把引用计数减一</li>
<li>如果引用计数还没有为 0 则直接返回了</li>
<li>如果是堆上的而且设置了 BLOCK_HAS_COPY_DISPOSE 就去执行 dispose，这个也留到后边来说明</li>
<li><code>_Block_deallocator</code> 就是 <code>free</code>， 用于释放堆上的 block 对象的内存</li>
<li>如果是全局或者栈上的 block 就什么都不执行</li>
</ol>


<p>总结一下：<br/>
1. 栈上的 block 对象在需要时会通过 <code>_Block_copy</code> 复制到堆上，从而达到脱离作用域也可以访问。
2. Flags 做为标记位，用于维护 block 的状态</p>

<p>额外说一点在下边这些情况下编译器都可以正确的处理复制：</p>

<ul>
<li>手动调用 <code>copy</code> 方法</li>
<li>block 作为函数的返回值</li>
<li>将 block 赋值为 <code>__strong</code> 修饰的 id 类型 或者 block 类型的成员变量</li>
<li>在方法名中含有 <code>usingBlock</code> 的 Cocoa 框架方法 和 GCD 的 的方法</li>
</ul>


<p><del>但是在某些情况下系统是无法高效的做出判断的，那么就需要我们自己来调用 <code>copy</code> 把 block 复制到堆上，例如 <code>[NSArray initWithObjects:]</code> 方法，如果我们不手动的执行 <code>copy</code> 当获取数组中的对象并且执行时是会崩溃的。大家可以自行尝试。</del> MRC 情况下才会出现, ARC 不会。</p>

<h4>block 引用变量的生命周期管理</h4>

<p>block 的生命周期管理可以很好的处理了，但我们发现麻烦事还没有结束，因为 block 还需要保证引用的变量的生命周期。
而在 block 被复制到堆上的过程中，block 一共需要处理 4 种类型的变量，而这些处理都是通过 <code>__main_block_desc_0</code> 中的 <code>copy</code> 来处理的。<br/>
需要处理的对象包括:</p>

<ul>
<li>C++ 栈对象</li>
<li>OC 对象</li>
<li>其它的 block</li>
<li>__block 修饰的变量</li>
</ul>


<p>我们来看看是怎么处理的</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="k">static</span> <span class="kt">void</span> <span class="nf">__main_block_copy_0</span><span class="p">(</span><span class="k">struct</span> <span class="n">__main_block_impl_0</span><span class="o">*</span><span class="n">dst</span><span class="p">,</span> <span class="k">struct</span> <span class="n">__main_block_impl_0</span><span class="o">*</span><span class="n">src</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// 1</span>
</span><span class='line'>    <span class="c1">// 2</span>
</span><span class='line'>    <span class="n">_block_object_assign</span><span class="p">((</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">dst</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">src</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="kt">void</span> <span class="nf">_Block_object_assign</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">destAddr</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">object</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="c1">// 3</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">((</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">BLOCK_BYREF_CALLER</span><span class="p">)</span> <span class="o">==</span> <span class="n">BLOCK_BYREF_CALLER</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">((</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">BLOCK_FIELD_IS_WEAK</span><span class="p">)</span> <span class="o">==</span> <span class="n">BLOCK_FIELD_IS_WEAK</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">_Block_assign_weak</span><span class="p">(</span><span class="n">object</span><span class="p">,</span> <span class="n">destAddr</span><span class="p">);</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>        <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>            <span class="c1">// do *not* retain or *copy* __block variables whatever they are</span>
</span><span class='line'>            <span class="n">_Block_assign</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">object</span><span class="p">,</span> <span class="n">destAddr</span><span class="p">);</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// 4</span>
</span><span class='line'>    <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">BLOCK_FIELD_IS_BYREF</span><span class="p">)</span> <span class="o">==</span> <span class="n">BLOCK_FIELD_IS_BYREF</span><span class="p">)</span>  <span class="p">{</span>
</span><span class='line'>        <span class="n">_Block_byref_assign_copy</span><span class="p">(</span><span class="n">destAddr</span><span class="p">,</span> <span class="n">object</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// 5</span>
</span><span class='line'>    <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">BLOCK_FIELD_IS_BLOCK</span><span class="p">)</span> <span class="o">==</span> <span class="n">BLOCK_FIELD_IS_BLOCK</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">_Block_assign</span><span class="p">(</span><span class="n">_Block_copy_internal</span><span class="p">(</span><span class="n">object</span><span class="p">,</span> <span class="n">flags</span><span class="p">),</span> <span class="n">destAddr</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// 6</span>
</span><span class='line'>    <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">BLOCK_FIELD_IS_OBJECT</span><span class="p">)</span> <span class="o">==</span> <span class="n">BLOCK_FIELD_IS_OBJECT</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">_Block_retain_object</span><span class="p">(</span><span class="n">object</span><span class="p">);</span>
</span><span class='line'>        <span class="n">_Block_assign</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">object</span><span class="p">,</span> <span class="n">destAddr</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<ol>
<li><code>__main_block_desc_0</code> 也是通过编译器自动生成，内部都回统一调用到 <code>_block_object_assign</code> 函数。</li>
<li>这里最后一个参数传入了 8，参数的含义是编译器用来告诉 <code>_block_object_assign</code> 捕获的对象是什么类型的。含义如下：<br/>
<code>BLOCK_FIELD_IS_OBJECT (3)</code>， OC 对象<br/>
<code>BLOCK_FIELD_IS_BLOCK (7)</code>， 其它的 block<br/>
<code>BLOCK_FIELD_IS_BYREF (8)</code>，__block 修饰的变量<br/>
如果 <code>BLOCK_FIELD_IS_BYREF</code> 还是 <code>__weak</code> 修饰的还要加上 <code>BLOCK_FIELD_IS_WEAK (16)</code><br/>
所以这里的 8 就是代表 <code>BLOCK_FIELD_IS_BYREF</code>，对应到我们之前定义的 <code>__block int val</code> 的类型。</li>
<li>如果 flags 设置了 <code>BLOCK_BYREF_CALLER</code>，那么简单的赋值复制就好，不需要 copy 了。</li>
<li>如果捕获对象的类型是 __block 修饰的变量, 那么把栈上的 <code>__block_byref_val_0</code> 对象复制到堆上。</li>
<li>如果捕获对象是 block，那么通过 <code>_Block_copy_internal</code> 把对象从栈上复制到堆上</li>
<li>如果捕获对象是 OC 对象，那么就引用计数加 1 即可。(这也是 block 循环引用发生的充分条件)</li>
</ol>


<p>至此 <code>__block_byref_val_0</code> 对象的生命周期在 block 被复制时也得到很好的管理了。<br/>
当堆上的 block 被释放时 <code>dispose</code> 也可能会被执行，从而在释放自动变量。</p>

<h4>__forwarding 的意义</h4>

<p>理解完 block 和 <code>__block_byref_val_0</code> 的复制操作，那么再来理解 <code>__forwarding</code> 就非常顺利了。<br/>
我们来看一段代码</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="c1">// 1</span>
</span><span class='line'><span class="n">__block</span> <span class="kt">int</span> <span class="n">val</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
</span><span class='line'><span class="c1">// 2</span>
</span><span class='line'><span class="o">++</span><span class="n">val</span><span class="p">;</span>
</span><span class='line'><span class="c1">// 2</span>
</span><span class='line'><span class="kt">void</span> <span class="p">(</span><span class="o">^</span><span class="n">blk</span><span class="p">)(</span><span class="kt">void</span><span class="p">)</span> <span class="o">=</span> <span class="o">^</span><span class="p">{</span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Hello, World! val = %d&quot;</span><span class="p">,</span> <span class="n">val</span><span class="p">);};</span>
</span><span class='line'><span class="c1">// 3</span>
</span><span class='line'><span class="o">++</span><span class="n">val</span><span class="p">;</span>
</span><span class='line'><span class="n">blk</span><span class="p">();</span>
</span></code></pre></td></tr></table></div></figure>


<ol>
<li>会生成栈上的 <code>__block_byref_val_0</code> 结构体对象</li>
<li>此时访问的是栈上的对象。</li>
<li><code>void (^blk)(void)</code> 相当于是 <code>__strong void (^blk)(void)</code>，所以这里的 block 对象在被 <code>void (^blk)(void)</code> 引用时 block 就被复制到堆上了，同时 <code>__block_byref_val_0</code> 也被复制到堆上了。</li>
<li>++val 操作的是堆上的对象。
所以问题的核心就是如何可以同时访问栈上和堆上的对象进行操作，从而获得正确的输出？<br/>
我们继续通过 clang 查看代码</li>
</ol>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="n">__Block_byref_val_0</span> <span class="n">val</span> <span class="o">=</span> <span class="p">{(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="mi">0</span><span class="p">,(</span><span class="n">__Block_byref_val_0</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">val</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">__Block_byref_val_0</span><span class="p">),</span> <span class="mi">3</span><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 1</span>
</span><span class='line'><span class="o">++</span><span class="p">(</span><span class="n">val</span><span class="p">.</span><span class="n">__forwarding</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">blk</span><span class="p">)(</span><span class="kt">void</span><span class="p">)</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">__main_block_impl_0</span><span class="p">(</span><span class="n">__main_block_func_0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">__main_block_desc_0_DATA</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">val</span><span class="p">,</span> <span class="mi">570425344</span><span class="p">));</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 2</span>
</span><span class='line'><span class="o">++</span><span class="p">(</span><span class="n">val</span><span class="p">.</span><span class="n">__forwarding</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="n">blk</span><span class="o">-&gt;</span><span class="n">impl</span><span class="p">.</span><span class="n">FuncPtr</span><span class="p">(</span><span class="n">blk</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>可以看到对 val 的访问都统一的通过 <code>__forwarding</code> 指针来访问，而 <code>__forwarding</code> 用于指向自己。
1. 此时 <code>__forwarding</code> 指向栈上的自己。
2. 此时 <code>__forwarding</code> 指向堆上的自己。
3. <code>__forwarding</code> 的作用的就是让 __block 修饰的变量不管在栈上还是在堆上都可以被正确的访问。</p>

<p>那么 <code>__forwarding</code> 的指针是什么时候改变的呢，显然应该是在 <code>__Block_byref_val_0</code> 被复制到堆上时，为了验证我们的猜想，在前边我们提到 <code>__Block_byref_val_0</code> 被复制到堆上时执行了 <code>_Block_byref_assign_copy</code> 这个函数，我们直接去看看源码的实现。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="k">static</span> <span class="kt">void</span> <span class="nf">_Block_byref_assign_copy</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">dest</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">struct</span> <span class="n">Block_byref</span> <span class="o">**</span><span class="n">destp</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">Block_byref</span> <span class="o">**</span><span class="p">)</span><span class="n">dest</span><span class="p">;</span>
</span><span class='line'>    <span class="k">struct</span> <span class="n">Block_byref</span> <span class="o">*</span><span class="n">src</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">Block_byref</span> <span class="o">*</span><span class="p">)</span><span class="n">arg</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="p">...</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">((</span><span class="n">src</span><span class="o">-&gt;</span><span class="n">forwarding</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">BLOCK_REFCOUNT_MASK</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>
</span><span class='line'>        <span class="kt">bool</span> <span class="n">isWeak</span> <span class="o">=</span> <span class="p">((</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">BLOCK_FIELD_IS_BYREF</span><span class="o">|</span><span class="n">BLOCK_FIELD_IS_WEAK</span><span class="p">))</span> <span class="o">==</span> <span class="p">(</span><span class="n">BLOCK_FIELD_IS_BYREF</span><span class="o">|</span><span class="n">BLOCK_FIELD_IS_WEAK</span><span class="p">));</span>
</span><span class='line'>        <span class="k">struct</span> <span class="n">Block_byref</span> <span class="o">*</span><span class="n">copy</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">Block_byref</span> <span class="o">*</span><span class="p">)</span><span class="n">_Block_allocator</span><span class="p">(</span><span class="n">src</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span> <span class="n">isWeak</span><span class="p">);</span>
</span><span class='line'>        <span class="n">copy</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">src</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|</span> <span class="n">_Byref_flag_initial_value</span><span class="p">;</span> <span class="c1">// non-GC one for caller, one for stack</span>
</span><span class='line'>        <span class="n">copy</span><span class="o">-&gt;</span><span class="n">forwarding</span> <span class="o">=</span> <span class="n">copy</span><span class="p">;</span> <span class="c1">// patch heap copy to point to itself (skip write-barrier)</span>
</span><span class='line'>        <span class="c1">// 1</span>
</span><span class='line'>        <span class="n">src</span><span class="o">-&gt;</span><span class="n">forwarding</span> <span class="o">=</span> <span class="n">copy</span><span class="p">;</span>  <span class="c1">// patch stack to point to heap copy</span>
</span><span class='line'>        <span class="n">copy</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="n">src</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="p">...</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<ol>
<li>就是这关键的一步把 <code>src-&gt;forwarding</code> 指向了在堆上新创建的对象。</li>
</ol>


<p>至此我们基本明白 block 的实现原理, 我们最后总结一下：</p>

<ol>
<li>block 会被编译成 C 的结构体，自动变量和函数会作为该结构的成员变量而被捕获。</li>
<li>block 和 block 变量对象 在编译器的帮助下通过 copy 和 release，来合理的管理生命周期，使得在作用域外也可以被正确的访问。</li>
</ol>


<h3>参考链接</h3>

<p><a href="https://zh.wikipedia.org/wiki/%E9%97%AD%E5%8C%85_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6">维基百科闭包</a><br/>
<a href="http://llvm.org/svn/llvm-project/compiler-rt/trunk/lib/BlocksRuntime/runtime.c">block 源码</a><br/>
<a href="http://www.galloway.me.uk/2013/05/a-look-inside-blocks-episode-3-block-copy/">A look inside blocks: Episode 3 </a></p>
</div>


  <footer>
    <p class="meta">
      
  

<span class="byline author vcard">Posted by <span class="fn"><a href="/about" title="About the author (Sring Zhao)" rel="author">Sring Zhao</a></span></span>

      








  


<time datetime="2018-03-11T12:13:52+08:00" pubdate data-updated="true"></time>
      


      <br>原文链接：<a href="http://strzhao.github.io/blog/2018/03/11/block-liao-jie-xia/">http://strzhao.github.io/blog/2018/03/11/block-liao-jie-xia/</a>

    </p>
    
      <div class="sharing">
  
  
  
</div>

    
    <p class="meta">
      
      
    </p>
  </footer>
</article>

</div>


    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2018 - Sring Zhao -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  











</body>
</html>
